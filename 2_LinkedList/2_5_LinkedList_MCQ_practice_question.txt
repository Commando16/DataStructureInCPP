____________________________________________________________________________________________________________________________

Practice MCQ type question on Linked list.
____________________________________________________________________________________________________________________________




----------------------------------------------------------------------------------------------------------------------------


Q1. 
What does the following function do for a given Linked List with first node as head?
void fun1(struct node* head)
{
  if(head == NULL)
    return;
  
  fun1(head->next);
  printf("%d  ", head->data);
}

A. Prints all nodes of linked lists
B. Prints all nodes of linked list in reverse order
C. Prints alternate nodes of Linked List
D. Prints alternate nodes in reverse order

Ans. B

Explanation: 
fun1() prints the given Linked List in reverse manner. For Linked List 1->2->3->4->5, fun1() prints 5->4->3->2->1.


----------------------------------------------------------------------------------------------------------------------------


Q2. 
Which of the following points is/are true about Linked List data structure when it is compared with array

A. Arrays have better cache locality that can make them better in terms of performance.
B. It is easy to insert and delete elements in Linked List
C. Random access is not allowed in a typical implementation of Linked Lists
D. The size of array has to be pre-decided, linked lists can change their size any time.
E. All of the above

Ans. E

----------------------------------------------------------------------------------------------------------------------------


Q3. 
Consider the following function that takes reference to head of a Doubly Linked List as parameter. Assume that a node of doubly linked list has previous pointer as prev and next pointer as next.

void fun(struct node **head_ref)
{
    struct node *temp = NULL;
    struct node *current = *head_ref;
 
    while (current !=  NULL)
    {
        temp = current->prev;
        current->prev = current->next;
        current->next = temp;
        current = current->prev;
    }
 
    if(temp != NULL )
        *head_ref = temp->prev;
}

Assume that reference of head of following doubly linked list is passed to above function 1 <--> 2 <--> 3 <--> 4 <--> 5 <-->6  What should be the modified linked list after the function call?

A. 2 <--> 1 <--> 4 <--> 3 <--> 6 <-->5
B. 5 <--> 4 <--> 3 <--> 2 <--> 1 <-->6.
C. 6 <--> 5 <--> 4 <--> 3 <--> 2 <--> 1.
D. 6 <--> 5 <--> 4 <--> 3 <--> 1 <--> 2

Ans. C


----------------------------------------------------------------------------------------------------------------------------


Q4. 
Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?

A. Insertion Sort
B. Quick Sort
C. Heap Sort
D. Merge Sort

Ans. D

Explanation: 
Both Merge sort and Insertion sort can be used for linked lists. The slow random-access performance of a linked list makes other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. Since worst case time complexity of Merge Sort is O(nLogn) and Insertion sort is O(n^2), merge sort is preferred. See following for implementation of merge sort using Linked List. http://www.geeksforgeeks.org/merge-sort-for-linked-list/
Question 5


----------------------------------------------------------------------------------------------------------------------------


Q5. 
The following function reverse() is supposed to reverse a singly linked list. There is one line missing at the end of the function.

/* Link list node */
struct node
{
    int data;
    struct node* next;
};
 
/* head_ref is a double pointer which points to head (or start) pointer 
  of linked list */
static void reverse(struct node** head_ref)
{
    struct node* prev   = NULL;
    struct node* current = *head_ref;
    struct node* next;
    while (current != NULL)
    {
        next  = current->next;  
        current->next = prev;   
        prev = current;
        current = next;
    }
    /*ADD A STATEMENT HERE*/
}

A. *head_ref = prev;
B. *head_ref = current;
C. *head_ref = next;
D. *head_ref = NULL;

Ans. A

Explanation: 
*head_ref = prev; At the end of while loop, the prev pointer points to the last node of original linked list. We need to change *head_ref so that the head pointer now starts pointing to the last node.


----------------------------------------------------------------------------------------------------------------------------


Q6. 
What is the output of following function for start pointing to first node of following linked list? 1->2->3->4->5->6

void fun(struct node* start)
{
  if(start == NULL)
    return;
  printf("%d  ", start->data); 
  
  if(start->next != NULL )
    fun(start->next->next);
  printf("%d  ", start->data);
}

A. 1 4 6 6 4 1
B. 1 3 5 1 3 5
C. 1 2 3 5
D. 1 3 5 5 3 1

Ans. D

Explanation: 
fun() prints alternate nodes of the given Linked List, first from head to end, and then from end to head. If Linked List has even number of nodes, then skips the last node.


----------------------------------------------------------------------------------------------------------------------------


Q7. 
The following C function takes a simply-linked list as input argument. It modifies the list by moving the last element to the front of the list and returns the modified list. Some part of the code is left blank. Choose the correct alternative to replace the blank line.

typedef struct node 
{
  int value;
  struct node *next;
}Node;
  
Node *move_to_front(Node *head) 
{
  Node *p, *q;
  if ((head == NULL: || (head->next == NULL)) 
    return head;
  q = NULL; p = head;
  while (p-> next !=NULL) 
  {
    q = p;
    p = p->next;
  }
  _______________________________
  return head;
}


A. q = NULL; p->next = head; head = p;
B. q->next = NULL; head = p; p->next = head;
C. head = p; p->next = q; q->next = NULL;
D. q->next = NULL; p->next = head; head = p;

Ans. D


----------------------------------------------------------------------------------------------------------------------------


Q8. 
The following C function takes a single-linked list of integers as a parameter and rearranges the elements of the list. The function is called with the list containing the integers 1, 2, 3, 4, 5, 6, 7 in the given order. What will be the contents of the list after the function completes execution?
struct node 
{
  int value;
  struct node *next;
};
void rearrange(struct node *list)
{
  struct node *p, * q;
  int temp;
  if ((!list) || !list->next) 
      return;
  p = list;
  q = list->next;
  while(q) 
  {
     temp = p->value;
     p->value = q->value;
     q->value = temp;
     p = q->next;
     q = p?p->next:0;
  }
}

A. 1,2,3,4,5,6,7
B. 2,1,4,3,6,5,7
C. 1,3,2,5,4,7,6
D. 2,3,4,5,6,7,1

Ans. B

Explanation: 
The function rearrange() exchanges data of every node with its next node. It starts exchanging data from the first node itself.


----------------------------------------------------------------------------------------------------------------------------


Q9. 
In the worst case, the number of comparisons needed to search a singly linked list of length n for a given element is (GATE CS 2002)

A. log 2 n
B. n/2
C. log 2 n – 1
D. n

Ans. D

Explanation: 
In the worst case, the element to be searched has to be compared with all elements of linked list.


----------------------------------------------------------------------------------------------------------------------------


Q10. 
Suppose each set is represented as a linked list with elements in arbitrary order. Which of the operations among union, intersection, membership, cardinality will be the slowest? (GATE CS 2004)

A. union only
B. intersection, membership
C. membership, cardinality
D. union, intersection

Ans. D 

Explanation: 
For getting intersection of L1 and L2, search for each element of L1 in L2 and print the elements we find in L2. There can be many ways for getting union of L1 and L2. One of them is as follows a) Print all the nodes of L1 and print only those which are not present in L2. b) Print nodes of L2. All of these methods will require more operations than intersection as we have to process intersection node plus other nodes.


----------------------------------------------------------------------------------------------------------------------------












____________________________________________________________________________________________________________________________

This set of Data Structure Multiple Choice Questions & Answers (MCQs) focuses on “Singly Linked List”.
____________________________________________________________________________________________________________________________

----------------------------------------------------------------------------------------------------------------------------


Q11. 
Which of the following is not a disadvantage to the usage of array?

a) Fixed size
b) There are chances of wastage of memory space if elements inserted in an array are lesser than the allocated size
c) Insertion based on position
d) Accessing elements at specified positions

Answer: d

Explanation: Array elements can be accessed in two steps. First, multiply the size of the data type with the specified position, second, add this value to the base address. Both of these operations can be done in constant time, hence accessing elements at a given index/position is faster.



----------------------------------------------------------------------------------------------------------------------------


Q12. 
What is the time complexity of inserting at the end in dynamic arrays?

a) O(1)
b) O(n)
c) O(logn)
d) Either O(1) or O(n)

Answer: d

Explanation: Depending on whether the array is full or not, the complexity in dynamic array varies. If you try to insert into an array that is not full, then the element is simply stored at the end, this takes O(1) time. If you try to insert into an array which is full, first you will have to allocate an array with double the size of the current array and then copy all the elements into it and finally insert the new element, this takes O(n) time.


----------------------------------------------------------------------------------------------------------------------------


Q13. 
What is the time complexity to count the number of elements in the linked list?

a) O(1)
b) O(n)
c) O(logn)
d) O(n2)

Answer: b

Explanation: To count the number of elements, you have to traverse through the entire list, hence complexity is O(n).



----------------------------------------------------------------------------------------------------------------------------


Q14. 
Which of the following performs deletion of the last element in the list? Given below is the Node class.

class Node
{
	protected Node next;
	protected Object ele;
	Node(Object e,Node n)
	{
		ele = e;
		next = n;
	}
	public void setNext(Node n)
	{
		next = n;
	}
	public void setEle(Object e)
	{
		ele = e;
	}
	public Node getNext()
	{
		return next;
	}
	public Object getEle()
	{
		return ele;
	}
}
class SLL 
{
	Node head;
	int size;
	SLL()
	{
		size = 0;
	}
}


a)
public Node removeLast()
{
	if(size == 0)
	return null;
	Node cur;
	Node temp;
	cur = head;
	while(cur.getNext() != null)
	{
		 temp = cur;
		 cur = cur.getNext();
        }
	temp.setNext(null);
	size--;
	return cur;
}

b)public void removeLast()
{
	if(size == 0)
	return null;
	Node cur;
	Node temp;
	cur = head;
	while(cur != null)
	{
		temp = cur;
		cur = cur.getNext();
        }
	temp.setNext(null);
	return cur;
}

c)
public void removeLast()
{
	if(size == 0)
	    return null;
	Node cur;
	Node temp;
	cur = head;
	while(cur != null)
	{
		cur = cur.getNext();
		temp = cur;
	 }
	temp.setNext(null);
	return cur;
}

d)
public void removeLast()
{
	if(size == 0)
		return null;
	Node cur;
	Node temp;
	cur = head;
	while(cur.getNext() != null)
	{
		cur = cur.getNext();
		temp = cur;
	}
	temp.setNext(null);
	return cur;
}

Answer: a

Explanation: Since you have to traverse to the end of the list and delete the last node, you need two reference pointers. ‘cur’ to traverse all the way and find the last node, and ‘temp’ is a trailing pointer to ‘cur’. Once you reach the end of the list, setNext of ‘temp’ to null, ‘cur’ is not being pointed to by any node, and hence it is available for garbage collection.


----------------------------------------------------------------------------------------------------------------------------


Q15. 
What is the functionality of the following code?

public void function(Node node)
{
	if(size == 0)
		head = node;
	else
	{
		Node temp,cur;
		for(cur = head; (temp = cur.getNext())!=null; cur = temp);
		cur.setNext(node);
	}
	size++;
}

a) Inserting a node at the beginning of the list
b) Deleting a node at the beginning of the list
c) Inserting a node at the end of the list
d) Deleting a node at the end of the list


Answer: c

Explanation: The for loop traverses through the list and then inserts a new node as cur.setNext(node);


----------------------------------------------------------------------------------------------------------------------------


Q16. 
What is the space complexity for deleting a linked list?

a) O(1)
b) O(n)
c) Either O(1) or O(n)
d) O(logn)


Answer: a

Explanation: You need a temp variable to keep track of current node, hence the space complexity is O(1).


----------------------------------------------------------------------------------------------------------------------------


Q17. 
How would you delete a node in the singly linked list? The position to be deleted is given.

a)
public void delete(int pos)
{
	if(pos < 0)
	pos = 0;
	if(pos > size)
	pos = size;
	if( size == 0)
	return;
	if(pos == 0)
	head = head.getNext();
	else
	{
	    Node temp = head;
	    for(int i=1; i<pos; i++)
            {
		temp = temp.getNext();
            }
	    temp.setNext(temp.getNext().getNext());
	}
	    size--;
}

b)
public void delete(int pos)
{
	if(pos < 0)
	pos = 0;
	if(pos > size)
	pos = size;
	if( size == 0)
	return;
	if(pos == 0)
	head = head.getNext();
	else
	{
	    Node temp = head;
	    for(int i=1; i<pos; i++)
	    {
		temp = temp.getNext();
	    }
	    temp.setNext(temp.getNext());
	}
	    size--;
}

c)
public void delete(int pos)
{
        if(pos < 0)
	pos = 0;
	if(pos > size)
	pos = size;
	if( size == 0)
	return;
	if(pos == 0)
	head = head.getNext();
	else
	{
	    Node temp = head;
	    for(int i=1; i<pos; i++)
	    {
		temp = temp.getNext().getNext();
            }
	    temp.setNext(temp.getNext().getNext());
	}
	    size--;
}

d)
public void delete(int pos)
{
        if(pos < 0)
        pos = 0;
        if(pos > size)
        pos = size;
        if( size == 0)
	return;
	if(pos == 0)
	head = head.getNext();
	else
	{
	    Node temp = head;
	    for(int i=0; i<pos; i++)
	    {
		temp = temp.getNext();
	    }
	    temp.setNext(temp.getNext().getNext());
	}
	size--;
}

Answer: a

Explanation: Loop through the list to get into position one behind the actual position given. temp.setNext(temp.getNext().getNext()) will delete the specified node.


----------------------------------------------------------------------------------------------------------------------------


Q18. 
Which of these is not an application of a linked list?

a) To implement file systems
b) For separate chaining in hash-tables
c) To implement non-binary trees
d) Random Access of elements
View Answer

Answer: d

Explanation: To implement file system, for separate chaining in hash-tables and to implement non-binary trees linked lists are used. Elements are accessed sequentially in linked list. Random access of elements is not an applications of linked list.
 

----------------------------------------------------------------------------------------------------------------------------


Q19. 
Which of the following piece of code has the functionality of counting the number of elements in the list?

a)
public int length(Node head)
{
	int size = 0;
	Node cur = head;
	while(cur!=null)
	{
	    size++;
	    cur = cur.getNext();
	}
	return size;
}

b)
public int length(Node head)
{
        int size = 0;
	Node cur = head;
	while(cur!=null)
	{
	    cur = cur.getNext();
	    size++;
	}
	return size;
}

c)
public int length(Node head)
{
	int size = 0;
	Node cur = head;
	while(cur!=null)
	{
	    size++;
	    cur = cur.getNext();
	}
}

d)
public int length(Node head)
{
	int size = 0;
	Node cur = head;
	while(cur!=null)
	{
	    size++;
	    cur = cur.getNext().getNext();
	}
	return size;
}

Answer: a

Explanation: ‘cur’ pointer traverses through list and increments the size variable until the end of list is reached.


----------------------------------------------------------------------------------------------------------------------------


Q20. 
How do you insert an element at the beginning of the list?

a)
public void insertBegin(Node node)
{
	node.setNext(head);
	head = node;
	size++;
}

b)
public void insertBegin(Node node)
{
	head = node;
	node.setNext(head);
	size++;
}

c)
public void insertBegin(Node node)
{
	Node temp = head.getNext()
	node.setNext(temp);
	head = node;
	size++;
}

d)
public void insertBegin(Node node)
{
	Node temp = head.getNext()
	node.setNext(temp);
	node = head;
	size++;
}

Answer: a

Explanation: Set the ‘next’ pointer point to the head of the list and then make this new node as the head.


----------------------------------------------------------------------------------------------------------------------------


Q21. 
What is the functionality of the following piece of code?

public int function(int data)
{
	Node temp = head;
	int var = 0;
	while(temp != null)
	{
		if(temp.getData() == data)
		{
			return var;
		}
		var = var+1;
		temp = temp.getNext();
	}
	return Integer.MIN_VALUE;
}

a) Find and delete a given element in the list
b) Find and return the given element in the list
c) Find and return the position of the given element in the list
d) Find and insert a new element in the list

Answer: c

Explanation: When temp is equal to data, the position of data is returned.


----------------------------------------------------------------------------------------------------------------------------











____________________________________________________________________________________________________________________________

Data Structure Questions and Answers – Singly Linked List Operations
____________________________________________________________________________________________________________________________


----------------------------------------------------------------------------------------------------------------------------


Q22. 
A linear collection of data elements where the linear node is given by means of pointer is called?

a) Linked list
b) Node list
c) Primitive list
d) Unordered list

Answer: a

Explanation: In Linked list each node has its own data and the address of next node. These nodes are linked by using pointers. Node list is an object that consists of a list of all nodes in a document with in a particular selected set of nodes.


----------------------------------------------------------------------------------------------------------------------------


Q23. 
Consider an implementation of unsorted singly linked list. Suppose it has its representation with a head pointer only. Given the representation, which of the following operation can be implemented in O(1) time?
i) Insertion at the front of the linked list
ii) Insertion at the end of the linked list
iii) Deletion of the front node of the linked list
iv) Deletion of the last node of the linked list

a) I and II
b) I and III
c) I, II and III
d) I, II and IV

Answer: b

Explanation: We know the head node in the given linked list. Insertion and deletion of elements at the front of the linked list completes in O (1) time whereas for insertion and deletion at the last node requires to traverse through every node in the linked list. Suppose there are n elements in a linked list, we need to traverse through each node. Hence time complexity becomes O(n).


----------------------------------------------------------------------------------------------------------------------------


Q24. 
In linked list each node contains a minimum of two fields. One field is data field to store the data second field is?

a) Pointer to character
b) Pointer to integer
c) Pointer to node
d) Node

Answer: c

Explanation: Each node in a linked list contains data and a pointer (reference) to the next node. Second field contains pointer to node.


----------------------------------------------------------------------------------------------------------------------------


Q25. 
What would be the asymptotic time complexity to add a node at the end of singly linked list, if the pointer is initially pointing to the head of the list?

a) O(1)
b) O(n)
c) θ(n)
d) θ(1)

Answer: c

Explanation: In case of a linked list having n elements, we need to travel through every node of the list to add the element at the end of the list. Thus asymptotic time complexity is θ(n).


----------------------------------------------------------------------------------------------------------------------------


Q26. 
What would be the asymptotic time complexity to insert an element at the front of the linked list (head is known)?

a) O(1)
b) O(n)
c) O(n2)
d) O(n3)

Answer: a

Explanation: To add an element at the front of the linked list, we will create a new node which holds the data to be added to the linked list and pointer which points to head position in the linked list. The entire thing happens within O (1) time. Thus the asymptotic time complexity is O (1).


----------------------------------------------------------------------------------------------------------------------------


Q27. 
What would be the asymptotic time complexity to find an element in the linked list?

a) O(1)
b) O(n)
c) O(n2)
d) O(n4)

Answer: b

Explanation: If the required element is in the last position, we need to traverse the entire linked list. This will take O (n) time to search the element.


----------------------------------------------------------------------------------------------------------------------------


Q28. 
What would be the asymptotic time complexity to insert an element at the second position in the linked list?

a) O(1)
b) O(n)
c) O(n2)
d) O(n3)

Answer: a

Explanation: A new node is created with the required element. The pointer of the new node points the node to which the head node of the linked list is also pointing. The head node pointer is changed and it points to the new node which we created earlier. The entire process completes in O (1) time. Thus the asymptotic time complexity to insert an element in the second position of the linked list is O (1).


----------------------------------------------------------------------------------------------------------------------------


Q29. 
The concatenation of two lists can be performed in O(1) time. Which of the following variation of the linked list can be used?

a) Singly linked list
b) Doubly linked list
c) Circular doubly linked list
d) Array implementation of list

Answer: c

Explanation: We can easily concatenate two lists in O (1) time using singly or doubly linked list, provided that we have a pointer to the last node at least one of the lists. But in case of circular doubly linked lists, we will break the link in both the lists and hook them together. Thus circular doubly linked list concatenates two lists in O (1) time.


----------------------------------------------------------------------------------------------------------------------------


Q30. 
Consider the following definition in c programming language.

struct node
{
    int data;
    struct node * next;
}
typedef struct node NODE;
NODE *ptr;
Which of the following c code is used to create new node?

a) ptr = (NODE*)malloc(sizeof(NODE));
b) ptr = (NODE*)malloc(NODE);
c) ptr = (NODE*)malloc(sizeof(NODE*));
d) ptr = (NODE)malloc(sizeof(NODE));

Answer: a

Explanation: As it represents the right way to create a node.


----------------------------------------------------------------------------------------------------------------------------


Q31. 
What kind of linked list is best to answer questions like “What is the item at position n?”

a) Singly linked list
b) Doubly linked list
c) Circular linked list
d) Array implementation of linked list

Answer: d

Explanation: Arrays provide random access to elements by providing the index value within square brackets. In the linked list, we need to traverse through each element until we reach the nth position. Time taken to access an element represented in arrays is less than the singly, doubly and circular linked lists. Thus, array implementation is used to access the item at the position n.


----------------------------------------------------------------------------------------------------------------------------


Q32. 
Linked lists are not suitable for the implementation of ___________

a) Insertion sort
b) Radix sort
c) Polynomial manipulation
d) Binary search
View Answer

Answer: d

Explanation: It cannot be implemented using linked lists.


----------------------------------------------------------------------------------------------------------------------------


Q33. 
Linked list is considered as an example of ___________ type of memory allocation.

a) Dynamic
b) Static
c) Compile time
d) Heap
View Answer

Answer: a

Explanation: As memory is allocated at the run time.


----------------------------------------------------------------------------------------------------------------------------


Q34. 
In Linked List implementation, a node carries information regarding ___________

a) Data
b) Link
c) Data and Link
d) Node
View Answer

Answer: b

Explanation: A linked list is a collection of objects linked together by references from an object to another object. By convention these objects are names as nodes. Linked list consists of nodes where each node contains one or more data fields and a reference(link) to the next node.


----------------------------------------------------------------------------------------------------------------------------


Q35. 
Linked list data structure offers considerable saving in _____________

a) Computational Time
b) Space Utilization
c) Space Utilization and Computational Time
d) Speed Utilization
View Answer

Answer: c

Explanation: Linked lists saves both space and time.


----------------------------------------------------------------------------------------------------------------------------


Q36. 
Which of the following points is/are not true about Linked List data structure when it is compared with an array?

a) Arrays have better cache locality that can make them better in terms of performance
b) It is easy to insert and delete elements in Linked List
c) Random access is not allowed in a typical implementation of Linked Lists
d) Access of elements in linked list takes less time than compared to arrays

Answer: d

Explanation: To access an element in a linked list, we need to traverse every element until we reach the desired element. This will take more time than arrays as arrays provide random access to its elements.


----------------------------------------------------------------------------------------------------------------------------


Q37. 
What does the following function do for a given Linked List with first node as head?

void fun1(struct node* head)
{
    if(head == NULL)
    return;
    fun1(head->next);
    printf("%d  ", head->data);
}

a) Prints all nodes of linked lists
b) Prints all nodes of linked list in reverse order
c) Prints alternate nodes of Linked List
d) Prints alternate nodes in reverse order

Answer: b

Explanation: fun1() prints the given Linked List in reverse manner.
For Linked List 1->2->3->4->5, fun1() prints 5->4->3->2->1.


----------------------------------------------------------------------------------------------------------------------------


Q38. 
Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?

a) Insertion Sort
b) Quick Sort
c) Heap Sort
d) Merge Sort

Answer: d

Explanation: Both Merge sort and Insertion sort can be used for linked lists. The slow random-access performance of a linked list makes other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. Since worst case time complexity of Merge Sort is O(nLogn) and Insertion sort is O(n2), merge sort is preferred.


----------------------------------------------------------------------------------------------------------------------------


Q39. 
The following function reverse() is supposed to reverse a singly linked list. There is one line missing at the end of the function.

/* Link list node */
struct node
{
    int data;
    struct node* next;
};
 
/* head_ref is a double pointer which points to head (or start) pointer 
  of linked list */
static void reverse(struct node** head_ref)
{
    struct node* prev   = NULL;
    struct node* current = *head_ref;
    struct node* next;
    while (current != NULL)
    {
        next  = current->next;  
        current->next = prev;   
        prev = current;
        current = next;
    }
    /*ADD A STATEMENT HERE*/
}
What should be added in place of “/*ADD A STATEMENT HERE*/”, so that the function correctly reverses a linked list.

a) *head_ref = prev;
b) *head_ref = current;
c) *head_ref = next;
d) *head_ref = NULL;

Answer: a

Explanation: *head_ref = prev; At the end of while loop, the prev pointer points to the last node of original linked list.
We need to change *head_ref so that the head pointer now starts pointing to the last node.


----------------------------------------------------------------------------------------------------------------------------


Q40. 
What is the output of following function for start pointing to first node of following linked list?

1->2->3->4->5->6
void fun(struct node* start)
{
    if(start == NULL)
    return;
    printf("%d  ", start->data); 
    if(start->next != NULL )
    fun(start->next->next);
    printf("%d  ", start->data);
}

a) 1 4 6 6 4 1
b) 1 3 5 1 3 5
c) 1 2 3 5
d) 1 3 5 5 3 1

Answer: d

Explanation: fun() prints alternate nodes of the given Linked List, first from head to end, and then from end to head.
If Linked List has even number of nodes, then skips the last node.


----------------------------------------------------------------------------------------------------------------------------


Q41. 
The following C function takes a simply-linked list as an input argument. It modifies the list by moving the last element to the front of the list and returns the modified list. Some part of the code is left blank. Choose the correct alternative to replace the blank line.

typedef struct node 
{
    int value;
    struct node *next;
}Node;
 
Node *move_to_front(Node *head) 
{
    Node *p, *q;
    if ((head == NULL: || (head->next == NULL)) 
    return head;
    q = NULL; p = head;
    while (p-> next !=NULL) 
    {
        q = p;
        p = p->next;
    }
   _______________________________
  return head;
}

a) q = NULL; p->next = head; head = p;
b) q->next = NULL; head = p; p->next = head;
c) head = p; p->next = q; q->next = NULL;
d) q->next = NULL; p->next = head; head = p;

Answer: d

Explanation: When while loop completes its execution, node ‘p’ refers to the last node whereas the ‘q’ node refers to the node before ‘p’ in the linked list. q->next=NULL makes q as the last node. p->next=head places p as the first node. the head must be modified to ‘p’ as ‘p’ is the starting node of the list (head=p). Thus the sequence of steps are q->next=NULL, p->next=head, head=p.


----------------------------------------------------------------------------------------------------------------------------


Q42. 
The following C function takes a single-linked list of integers as a parameter and rearranges the elements of the list. The function is called with the list containing the integers 1, 2, 3, 4, 5, 6, 7 in the given order. What will be the contents of the list after the function completes execution?

struct node 
{
    int value;
    struct node *next;
};
void rearrange(struct node *list)
{
    struct node *p, * q;
    int temp;
    if ((!list) || !list->next) 
      return;
    p = list;
    q = list->next;
    while(q) 
    {
         temp = p->value;
         p->value = q->value;
         q->value = temp;
         p = q->next;
         q = p?p->next:0;
    }
}

a) 1, 2, 3, 4, 5, 6, 7
b) 2, 1, 4, 3, 6, 5, 7
c) 1, 3, 2, 5, 4, 7, 6
d) 2, 3, 4, 5, 6, 7, 1

Answer: b

Explanation: The function rearrange() exchanges data of every node with its next node. It starts exchanging data from the first node itself.


----------------------------------------------------------------------------------------------------------------------------


Q43. 
In the worst case, the number of comparisons needed to search a singly linked list of length n for a given element is?

a) log 2 n
b) n⁄2
c) log 2 n – 1
d) n

Answer: d

Explanation: In the worst case, the element to be searched has to be compared with all elements of the linked list.


----------------------------------------------------------------------------------------------------------------------------


Q44. 
Given pointer to a node X in a singly linked list. Only one pointer is given, pointer to head node is not given, can we delete the node X from given linked list?

a) Possible if X is not last node
b) Possible if size of linked list is even
c) Possible if size of linked list is odd
d) Possible if X is not first node

Answer: a

Explanation: Following are simple steps.
    struct node *temp  = X->next;
    X->data  = temp->data;
    X->next  = temp->next;
    free(temp);


----------------------------------------------------------------------------------------------------------------------------


Q45. 
You are given pointers to first and last nodes of a singly linked list, which of the following operations are dependent on the length of the linked list?

a) Delete the first element
b) Insert a new element as a first element
c) Delete the last element of the list
d) Add a new element at the end of the list

Answer: c

Explanation: Deletion of the first element of the list is done in O (1) time by deleting memory and changing the first pointer.
Insertion of an element as a first element can be done in O (1) time. We will create a node that holds data and points to the head of the given linked list. The head pointer was changed to a newly created node.
Deletion of the last element requires a pointer to the previous node of last, which can only be obtained by traversing the list. This requires the length of the linked list.
Adding a new element at the end of the list can be done in O (1) by changing the pointer of the last node to the newly created node and last is changed to a newly created node.


----------------------------------------------------------------------------------------------------------------------------


Q46. 
In the worst case, the number of comparisons needed to search a singly linked list of length n for a given element is?

a) log2 n
b) n⁄2
c) log2 n – 1
d) n

Answer: d

Explanation: The worst-case happens if the required element is at last or the element is absent in the list. For this, we need to compare every element in the linked list. If n elements are there, n comparisons will happen in the worst case.


----------------------------------------------------------------------------------------------------------------------------








____________________________________________________________________________________________________________________________

This set of Data Structure Multiple Choice Questions & Answers (MCQs) focuses on “Doubly Linked List”.
____________________________________________________________________________________________________________________________

----------------------------------------------------------------------------------------------------------------------------


Q47. 
Which of the following is false about a doubly linked list?

a) We can navigate in both the directions
b) It requires more space than a singly linked list
c) The insertion and deletion of a node take a bit longer
d) Implementing a doubly linked list is easier than singly linked list

Answer: d

Explanation: A doubly linked list has two pointers ‘left’ and ‘right’ which enable it to traverse in either direction. Compared to singly liked list which has only a ‘next’ pointer, doubly linked list requires extra space to store this extra pointer. Every insertion and deletion requires manipulation of two pointers, hence it takes a bit longer time. Implementing doubly linked list involves setting both left and right pointers to correct nodes and takes more time than singly linked list.


----------------------------------------------------------------------------------------------------------------------------


Q48. 
Given the Node class implementation, select one of the following that correctly inserts a node at the tail of the list.

public class Node
{
	protected int data;
	protected Node prev;
	protected Node next;
	public Node(int data)
	{
		this.data = data;
		prev = null;
		next = null;
	}
	public Node(int data, Node prev, Node next)
	{
		this.data = data;
		this.prev = prev;
		this.next = next;
	}
	public int getData()
	{
		return data;
	}
	public void setData(int data)
	{
		this.data = data;
	}
	public Node getPrev()
	{
		return prev;
	}
	public void setPrev(Node prev)
	{
		this.prev = prev;
	}
	public Node getNext
	{
		return next;
	}
	public void setNext(Node next)
	{
		this.next = next;
	}
}
public class DLL
{
	protected Node head;
	protected Node tail;
	int length;
	public DLL()
	{
		head = new Node(Integer.MIN_VALUE,null,null);
		tail = new Node(Integer.MIN_VALUE,null,null);
		head.setNext(tail);
		length = 0;
	}
}

a)
public void insertRear(int data)
{
	Node node = new Node(data,tail.getPrev(),tail);
	node.getPrev().setNext(node);
	tail.setPrev(node);
	length++;
}

b)
public void insertRear(int data)
{
	Node node = new Node(data,tail.getPrev(),tail);
	node.getPrev().getPrev().setNext(node);
	tail.setPrev(node);
	length++;
}

c)public void insertRear(int data)
{
	Node node = new Node(data,tail.getPrev(),tail);
	node.getPrev().setNext(tail);
	tail.setPrev(node);
	length++;
}

d)
public void insertRear(int data)
{
	Node node = new Node(data,head,tail);
	node.getPrev().setNext(node);
	tail.setPrev(node);
	length++;
}

Answer: a

Explanation: First create a new node whose ‘prev’ points to the node pointed to by the ‘prev’ of tail. The ‘next’ of the new node should point to tail. Set the ‘prev’ of tail to point to new node and the ‘prev’ of new node to point to the new node.
 

----------------------------------------------------------------------------------------------------------------------------

 
Q49. 
What is a memory efficient double linked list?

a) Each node has only one pointer to traverse the list back and forth
b) The list has breakpoints for faster traversal
c) An auxiliary singly linked list acts as a helper list to traverse through the doubly linked list
d) A doubly linked list that uses bitwise AND operator for storing addresses


Answer: a

Explanation: Memory efficient doubly linked list has only one pointer to traverse the list back and forth. The implementation is based on pointer difference. It uses bitwise XOR operator to store the front and rear pointer addresses. Instead of storing actual memory address, every node store the XOR address of previous and next nodes.


----------------------------------------------------------------------------------------------------------------------------





Q50. 
Which of the following piece of code removes the node from a given position?

a)
public void remove(int pos)
{
	if(pos<0 || pos>=size)
	{
		System.out.println("Invalid position");
		return;
	}
	else
	{
		if(head == null)
			return;
		if(pos == 0)
		{
			head = head.getNext();
			if(head == null)
			tail = null;
		}
	        else
	        {
			Node temp = head;
			for(int i=1; i<position; i++)
			temp = temp.getNext();
		}
		temp.getNext().setPrev(temp.getPrev());
		temp.getPrev().setNext(temp.getNext());
	}
	size--;
}

b)
public void remove(int pos)
{
	if(pos<0 || pos>=size)
	{
		System.out.println("Invalid position");
		return;
	}
	else
	{
		if(head == null)
		return;
		if(pos == 0)
		{
			head = head.getNext();
			if(head == null)
			tail = null;
		}
		else
		{
			Node temp = head;
			for(int i=1; i<position; i++)
			temp = temp.getNext();
		}
		temp.getNext().setPrev(temp.getNext());
		temp.getPrev().setNext(temp.getPrev());
	}
	size--;
}

c)
public void remove(int pos)
{
	if(pos<0 || pos>=size)
	{
		System.out.println("Invalid position");
		return;
	}
	else
	{
		if(head == null)
			return;
		if(pos == 0)
		{
			head = head.getNext();
			if(head == null)
			tail = null;
		}
		else
		{
			Node temp = head;
			for(int i=1; i<position; i++)
			temp = temp.getNext().getNext();
		}
		temp.getNext().setPrev(temp.getPrev());
		temp.getPrev().setNext(temp.getNext());
	}
	size--;
}

d)
public void remove(int pos)
{
	if(pos<0 || pos>=size)
	{
		System.out.println("Invalid position");
		return;
	}
	else
	{
		if(head == null)
			return;
		if(pos == 0)
		{
			head = head.getNext();
			if(head == null)
			tail = null;
		}
		else
		{
			Node temp = head;
			for(int i=1; i<position; i++)
			temp = temp.getNext().getNext();
		}
		temp.getNext().setPrev(temp.getNext());
		temp.getPrev().setNext(temp.getPrev());
	}
	size--;
}

Answer: a

Explanation: If the position to be deleted is not the head, advance to the given position and manipulate the previous and next pointers of next and previous nodes respectively.
 
 
----------------------------------------------------------------------------------------------------------------------------


Q51. 
How do you calculate the pointer difference in a memory efficient double linked list?

a) head xor tail
b) pointer to previous node xor pointer to next node
c) pointer to previous node – pointer to next node
d) pointer to next node – pointer to previous node

Answer: b

Explanation: The pointer difference is calculated by taking XOR of pointer to previous node and pointer to the next node.


----------------------------------------------------------------------------------------------------------------------------


Q52. 
What is the worst case time complexity of inserting a node in a doubly linked list?

a) O(nlogn)
b) O(logn)
c) O(n)
d) O(1)

Answer: c

Explanation: In the worst case, the position to be inserted maybe at the end of the list, hence you have to traverse through the entire list to get to the correct position, hence O(n).


----------------------------------------------------------------------------------------------------------------------------


Q53. 
How do you insert a node at the beginning of the list?

a)
public class insertFront(int data)
{
	Node node = new Node(data, head, head.getNext());
	node.getNext().setPrev(node);
	head.setNext(node);
	size++;
}

b)
public class insertFront(int data)
{
	Node node = new Node(data, head, head);
	node.getNext().setPrev(node);
	head.setNext(node);
	size++;
}

c)
public class insertFront(int data)
{
	Node node = new Node(data, head, head.getNext());
	node.getNext().setPrev(head);
	head.setNext(node);
	size++;
}

d)
public class insertFront(int data)
{
	Node node = new Node(data, head, head.getNext());
	node.getNext().setPrev(node);
	head.setNext(node.getNext());
	size++;
}


Answer: a

Explanation: The new node’s previous pointer will point to head and next pointer will point to the current next of head.
 
 
----------------------------------------------------------------------------------------------------------------------------


Q54. 
Consider the following doubly linked list: head-1-2-3-4-5-tail. What will be the list after performing the given sequence of operations?

	Node temp = new Node(6,head,head.getNext());
	Node temp1 = new Node(0,tail.getPrev(),tail);
	head.setNext(temp);
	temp.getNext().setPrev(temp);
	tail.setPrev(temp1);
	temp1.getPrev().setNext(temp1);

a) head-0-1-2-3-4-5-6-tail
b) head-1-2-3-4-5-6-tail
c) head-6-1-2-3-4-5-0-tail
d) head-0-1-2-3-4-5-tail

Answer: c

Explanation: The given sequence of operations performs addition of nodes at the head and tail of the list.


----------------------------------------------------------------------------------------------------------------------------


Q55. 
What is the functionality of the following piece of code?

public int function()
{
	Node temp = tail.getPrev();
	tail.setPrev(temp.getPrev());
	temp.getPrev().setNext(tail);
	size--;
	return temp.getItem();
}

a) Return the element at the tail of the list but do not remove it
b) Return the element at the tail of the list and remove it from the list
c) Return the last but one element from the list but do not remove it
d) Return the last but one element at the tail of the list and remove it from the list

Answer: b

Explanation: The previous and next pointers of the tail and the last but one element are manipulated, this suggests that the last node is being removed from the list.


----------------------------------------------------------------------------------------------------------------------------


Q56. 
Consider the following doubly linked list: head-1-2-3-4-5-tail. What will be the list after performing the given sequence of operations?

	Node temp = new Node(6,head,head.getNext());
	head.setNext(temp);
	temp.getNext().setPrev(temp);
	Node temp1 = tail.getPrev();
	tail.setPrev(temp1.getPrev());
	temp1.getPrev().setNext(tail);

a) head-6-1-2-3-4-5-tail
b) head-6-1-2-3-4-tail
c) head-1-2-3-4-5-6-tail
d) head-1-2-3-4-5-tail

Answer: b

Explanation: A new node is added to the head of the list and a node is deleted from the tail end of the list.


----------------------------------------------------------------------------------------------------------------------------








____________________________________________________________________________________________________________________________

This set of Data Structure Multiple Choice Questions & Answers (MCQs) focuses on “Circular Linked List”.
____________________________________________________________________________________________________________________________
----------------------------------------------------------------------------------------------------------------------------


Q57. What differentiates a circular linked list from a normal linked list?

a) You cannot have the ‘next’ pointer point to null in a circular linked list
b) It is faster to traverse the circular linked list
c) You may or may not have the ‘next’ pointer point to null in a circular linked list
d) Head node is known in circular linked list

Answer: c

Explanation: The ‘next’ pointer points to null only when the list is empty, otherwise it points to the head of the list. Every node in a circular linked list can be a starting point(head).


----------------------------------------------------------------------------------------------------------------------------


Q58. How do you count the number of elements in the circular linked list?

a)
public int length(Node head)
{
	int length = 0;
	if( head == null)
		return 0;
	Node temp = head.getNext();
	while(temp != head)
	{
		temp = temp.getNext();
		length++;
	}
	return length;
}

b)
public int length(Node head)
{
	int length = 0;
	if( head == null)
		return 0;
	Node temp = head.getNext();
	while(temp != null)
	{
		temp = temp.getNext();
		length++;
	}
	return length;
}

c)
public int length(Node head)
{
	int length = 0;
	if( head == null)
		return 0;
	Node temp = head.getNext();
	while(temp != head && temp != null)
	{
		temp = head.getNext();
		length++;
	}
	return length;
}

d)
public int length(Node head)
{
	int length = 0;
	if( head == null)
		return 0;
	Node temp = head.getNext();
	while(temp != head && temp == null)
	{
		temp = head.getNext();
		length++;
	}
	return length;
}

Answer: a

Explanation: If the head is null, it means that the list is empty. Otherwise, traverse the list until the head of the list is reached.


----------------------------------------------------------------------------------------------------------------------------


Q59. What is the functionality of the following piece of code? Select the most appropriate.

public void function(int data)
{
	int flag = 0;
	if( head != null)
	{
		Node temp = head.getNext();
		while((temp != head) && (!(temp.getItem() == data)))
		{
			temp = temp.getNext();
			flag = 1;
			break;
		}
	}
	if(flag)
		System.out.println("success");
	else
		System.out.println("fail");
}

a) Print success if a particular element is not found
b) Print fail if a particular element is not found
c) Print success if a particular element is equal to 1
d) Print fail if the list is empty

Answer: b

Explanation: The function prints fail if the given element is not found. Note that this option is inclusive of option “Print fail if the list is empty”, the list being empty is one of the cases covered.


----------------------------------------------------------------------------------------------------------------------------


Q60. What is the time complexity of searching for an element in a circular linked list?

a) O(n)
b) O(nlogn)
c) O(1)
d) O(n2)

Answer: a

Explanation: In the worst case, you have to traverse through the entire list of n elements.


----------------------------------------------------------------------------------------------------------------------------


Q61. Which of the following application makes use of a circular linked list?

a) Undo operation in a text editor
b) Recursive function calls
c) Allocating CPU to resources
d) Implement Hash Tables

Answer: c

Explanation: Generally, round robin fashion is employed to allocate CPU time to resources which makes use of the circular linked list data structure. Recursive function calls use stack data structure. Undo Operation in text editor uses doubly linked lists. Hash tables uses singly linked lists.


----------------------------------------------------------------------------------------------------------------------------


Q62. Choose the code snippet which inserts a node to the head of the list?

a)
public void insertHead(int data)
{
	Node temp = new Node(data);
	Node cur = head;
	while(cur.getNext() != head)
		cur = cur.getNext()
	if(head == null)
	{
		head = temp;
		head.setNext(head);
	}
	else
	{
		temp.setNext(head);
		head = temp;
		cur.setNext(temp);
	}
	size++;
}

b)
public void insertHead(int data)
{
	Node temp = new Node(data);
	while(cur != head)
		cur = cur.getNext()
	if(head == null)
	{
		head = temp;
		head.setNext(head);
	}
	else
	{
		temp.setNext(head.getNext());
		cur.setNext(temp);
	}
	size++;
}

c)
public void insertHead(int data)
{
	Node temp = new Node(data);
	if(head == null)
	{
		head = temp;
		head.setNext(head);
	}
	else
	{
		temp.setNext(head.getNext());
		head = temp;
	}
	size++;
}

d)
public void insertHead(int data)
{
	Node temp = new Node(data);
	if(head == null)
	{
		head = temp;
		head.setNext(head.getNext());
	}
	else
	{
		temp.setNext(head.getNext());
		head = temp;
	}
	size++;
}

Answer: a

Explanation: If the list is empty make the new node as ‘head’, otherwise traverse the list to the end and make its ‘next’ pointer point to the new node, set the new node’s next point to the current head and make the new node as the head.


----------------------------------------------------------------------------------------------------------------------------


Q63. What is the functionality of the following code? Choose the most appropriate answer.

public int function()
{
	if(head == null)
		return Integer.MIN_VALUE;
	int var;
	Node temp = head;
	while(temp.getNext() != head)
		temp = temp.getNext();
	if(temp == head)
	{
		var = head.getItem();
		head = null;
		return var;
	}
	temp.setNext(head.getNext());
	var = head.getItem();
	head = head.getNext();
	return var;
}

a) Return data from the end of the list
b) Returns the data and deletes the node at the end of the list
c) Returns the data from the beginning of the list
d) Returns the data and deletes the node from the beginning of the list

Answer: d

Explanation: First traverse through the list to find the end node, then manipulate the ‘next’ pointer such that it points to the current head’s next node, return the data stored in head and make this next node as the head.


----------------------------------------------------------------------------------------------------------------------------


Q64. What is the functionality of the following code? Choose the most appropriate answer.

public int function()
{
	if(head == null)
		return Integer.MIN_VALUE;
	int var;
	Node temp = head;
	Node cur;
	while(temp.getNext() != head)
	{
		cur = temp;
		temp = temp.getNext();
	}
	if(temp == head)
	{
		var = head.getItem();
		head = null;
		return var;
	}
	var = temp.getItem();
	cur.setNext(head);
	return var;
}

a) Return data from the end of the list
b) Returns the data and deletes the node at the end of the list
c) Returns the data from the beginning of the list
d) Returns the data and deletes the node from the beginning of the list

Answer: b

Explanation: First traverse through the list to find the end node, also have a trailing pointer to find the penultimate node, make this trailing pointer’s ‘next’ point to the head and return the data stored in the ‘temp’ node.


----------------------------------------------------------------------------------------------------------------------------


Q65. Which of the following is false about a circular linked list?
a) Every node has a successor
b) Time complexity of inserting a new node at the head of the list is O(1)
c) Time complexity for deleting the last node is O(n)
d) We can traverse the whole circular linked list by starting from any point

Answer: b

Explanation: Time complexity of inserting a new node at the head of the list is O(n) because you have to traverse through the list to find the tail node.


----------------------------------------------------------------------------------------------------------------------------


Q66. Consider a small circular linked list. How to detect the presence of cycles in this list effectively?
a) Keep one node as head and traverse another temp node till the end to check if its ‘next points to head
b) Have fast and slow pointers with the fast pointer advancing two nodes at a time and slow pointer advancing by one node at a time
c) Cannot determine, you have to pre-define if the list contains cycles
d) Circular linked list itself represents a cycle. So no new cycles cannot be generated

Answer: b

Explanation: Advance the pointers in such a way that the fast pointer advances two nodes at a time and slow pointer advances one node at a time and check to see if at any given instant of time if the fast pointer points to slow pointer or if the fast pointer’s ‘next’ points to the slow pointer. This is applicable for smaller lists.


----------------------------------------------------------------------------------------------------------------------------





----------------------------------------------------------------------------------------------------------------------------





----------------------------------------------------------------------------------------------------------------------------





----------------------------------------------------------------------------------------------------------------------------





----------------------------------------------------------------------------------------------------------------------------





*************************************************************************************************************************

SOURCES-
- https://www.sanfoundry.com/
- https://www.geeksforgeeks.org/

*************************************************************************************************************************